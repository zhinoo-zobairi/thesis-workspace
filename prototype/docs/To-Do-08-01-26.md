# What files to copy or adapt for each task?
## 1. Create MQTT Inspector

- `modbus.cc`: `class Modbus : public Inspector`, `Modbus::eval(Packet*)`, `Modbus::get_buf(...)`, `Modbus::get_splitter(bool)`
- `modbus.h`: `struct ModbusFlowData`
- `inspector.h`: `class snort::Inspector` interface (inherit + overrides)


## 2. Register Inspectors

- `modbus.cc`: `modbus_init()`, `modbus_ctor(...)`, `modbus_dtor(...)`, `InspectApi` (`PT_INSPECTOR`), `sin_modbus[]` (`#ifdef BUILDING_SO`)
- `service_inspectors.cc`: `load_service_inspectors()`
- top-level `CMakeLists.txt`: add mqtt subdir
- mqtt `CMakeLists.txt`: module/library build template
- `modbus_module.h`: `class ModbusModule : public snort::Module`
- `modbus_module.cc`


## 3. Parse Publish Messages

- `modbus_decode.cc`: `ModbusDecode(...)`
- `modbus_decode.h`
- `modbus_paf.h`: `class ModbusSplitter : public StreamSplitter`
- `modbus_paf.cc`
- `dns.cc`

## 4. Publish Topic/Events

- `data_bus.h`: `class DataEvent`, `DataBus::publish(...)`
- `pub_sub/dns_events.h`
- `pub_sub/http_events.h`
- `dns_payload_event_handler.cc`
- `pub_sub/mqtt_events.h`
- `modbus.cc`

- `ips_modbus_data.cc`: IPS option implementation pattern

**Core glue**
- `base_api.h`: `BaseApi`
- `module.h`: `snort::Module`
- `dev_notes.txt`

```
Byte Layout of PUBLISH Packet:
════════════════════════════════════════════════════════════════════

┌─────────────────────────────────────────────────────────────────┐
│ FIXED HEADER (2-5 bytes)                                        │
├─────────────────────────────────────────────────────────────────┤
│ Byte 0: Control Packet Type + Flags                             │
│   Bits 7-4: Packet Type = 0011 (3 = PUBLISH)                    │
│   Bit 3:    DUP flag (duplicate delivery)                       │
│   Bits 2-1: QoS level (00=0, 01=1, 10=2)   ← We extract this!   │
│   Bit 0:    RETAIN flag                                         │
├─────────────────────────────────────────────────────────────────┤
│ Byte 1-4: Remaining Length (variable length encoding)           │
│   1-4 bytes depending on packet size                            │
│   Bit 7 (0x80): Continuation bit (1=more bytes follow)          │
│   Bits 6-0 (0x7F): Length value                                 │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│ VARIABLE HEADER (variable length)                               │
├─────────────────────────────────────────────────────────────────┤
│ Bytes N, N+1: Topic Length (2 bytes, big-endian)                │
│   MSB first, then LSB                                           │
│   Example: 0x00 0x0B = 11 bytes                                 │
├─────────────────────────────────────────────────────────────────┤
│ Bytes N+2 to N+2+TopicLen-1: Topic String (UTF-8)               │
│   Example: "temperature" (11 bytes)                             │
│   ↑↑↑ get_buf_mqtt_topic() extracts THIS                        │
├─────────────────────────────────────────────────────────────────┤
│ Bytes (optional): Packet Identifier (2 bytes)                   │
│   ONLY present if QoS > 0                                       │
│   MSB, LSB (big-endian)                                         │
│   Used for QoS 1 (PUBACK) and QoS 2 (PUBREC/PUBREL/PUBCOMP)     │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│ PAYLOAD (remaining bytes)                                       │
├─────────────────────────────────────────────────────────────────┤
│ Bytes: Application Message (any binary data)                    │
│   Example: "72.5" or JSON: {"temp":72.5,"unit":"F"}             │
│   ↑↑↑ get_buf_mqtt_payload() extracts THIS                      │
│   Length = (Remaining Length) - (Variable Header Length)        │
└─────────────────────────────────────────────────────────────────┘
```
```
Raw bytes in memory (p->data):

Offset  Bytes       Field                    Parsing
──────────────────────────────────────────────────────────────────
0x00    0x32        Fixed Header Byte 1      
                    ════════════════════
                    Binary: 0011 0010
                            ││││ │││└─ RETAIN = 0
                            ││││ ││└── QoS bit 0 = 1
                            ││││ │└─── QoS bit 1 = 0  → QoS = 1
                            ││││ └──── DUP = 0
                            └┴┴┴────── Type = 3 (PUBLISH)

0x01    0x15        Remaining Length         = 21 bytes
                    (bit 7 = 0, so only 1 byte for length)

        ════════════ Variable Header Starts ════════════

0x02    0x00        Topic Length MSB         0x00
0x03    0x0C        Topic Length LSB         0x0C
                    Combined: 0x000C = 12 bytes

0x04-0x0F           Topic String             "sensors/temp"
        s e n s o r s / t e m p

0x10    0x00        Packet ID MSB            0x00
0x11    0x01        Packet ID LSB            0x01
                    Combined: 0x0001 = packet ID 1
                    (Present because QoS = 1)

        ════════════ Payload Starts ════════════

0x12-0x15           Payload                  "72.5"
        7 2 . 5

Total packet: 22 bytes (0x00 to 0x15)
```
```
Packet bytes:  0x32  0x15  0x00  0x0C  's'   'e'   'n'   's'   'o'   'r'
Index:         [0]   [1]   [2]   [3]   [4]   [5]   [6]   [7]   [8]   [9]
               ↑     ↑     ↑     ↑     ↑─────────────────────────────↑
               │     │     │     │     Topic string starts here
               │     │     │     │
               │     │     │     Topic length LSB (0x0C = 12)
               │     │     Topic length MSB (0x00)
               │     Remaining length (0x15 = 21 bytes)
               Fixed header byte 1 (0x32)
```
