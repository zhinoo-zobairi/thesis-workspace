## MQTT (Message Queuing Telemetry Transport) is a lightweight communication protocol

## The architecture
### Publish–Subscribe model, unlike HTTP which is request–response:

| Role           | Description                                                                                      | Example                                                                               |
| -------------- | ------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------- |
| **Broker**     | The *central server* (a **software processes**, a program that is currently running on a machine, the **active execution of code inside memory**) that receives messages from publishers and distributes them to subscribers. |  **Locally hosted** (e.g., running on a Raspberry Pi in your smart home network)  OR **Cloud-based** offered by services like: *Eclipse Mosquitto*, *HiveMQ*, *EMQX*, or *AWS IoT Core*                                                    |
| **Publisher**  | A device or app that sends out (“publishes”) data to a topic.                                    | A temperature sensor publishing: `topic = "home/livingroom/temp"`, message = `22.3°C` |
| **Subscriber** | A device or app that listens (“subscribes”) to a specific topic.                                 | A mobile app subscribed to `"home/livingroom/temp"` to display temperature updates.   |


## Topic-based addressing

- Every message in MQTT is labeled with a topic name (like a folder or channel).

- Subscribers only get messages from the topics they care about

## Different types of DoS attack
- flooding denial of service with the broker as target
- MQTT Publish Flood from a single malicious IoT device
- SlowITe, which initiates a large amount of connections with the MQTT broker
- an attack with malformed data sent to the MQTT broker to raise exceptions

### In a Network Intrusion Detection System (NIDS), IP addresses are volatile identifiers. The model shouldn't be trained using IP addresses (both sender and receiver) as part of its input features. That makes the model environment-dependent — it performs well on that specific dataset but fails in new, real networks with different IPs.

### Scikit-learn is a widely used Python machine-learning library. It provides convenient tools to manipulate datasets — including resampling, which means changing the number of samples per class to reduce imbalance: Oversampling, Undersampling, Combined resampling

### “SSH Sparta” = traffic generated by an SSH brute-force password-guessing tool; Realistic but hard to detect

### Snort 3’s architecture gives me:
- clean hooks for custom inspectors (like my MQTT/IoT-specific modules)
- event-based callbacks
- per-inspector memory
- stateful flow management
- modular plugin development
- output hooks for ML→Snort decision loops

My work will build on these APIs:

```Snort inspector → extract MQTT features → call ML model → return risk score → raise Snort event```

*My MQTT inspector is a Snort 3 plugin that analyzes MQTT traffic, extracts features, calls an external or embedded ML model, and then maps the model’s score to Snort actions:*
- The inspector = integration layer inside Snort.
- The ML model = decision engine that the inspector calls.
